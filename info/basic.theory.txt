Node is about scale and speed of development.
To build highly-scalable (non blocking, async nature), data-intensive, and real-time apps.
Node uses Javascript - a lot of programmers know it.
Open-source libraries, you don't have to rebuild a lot of things.

Theory.
Every Browser has JS Engine, it takes JS Code and compiling a machine code from it, so computer can run it.
Edge has chakra (chromium for now), FireFox - SpiderMonkey (Gecko), Chrome V8 (Blink as rendering engine),
Safari - WebKit, Opera - Presto (chromium for now)

Wait what’s Blink? It’s a bit confusing, as Blink is Google Chrome’s rendering engine, V8 is the JavaScript Engine used
within Blink, and Chromium is the browser project that holds them all together. Add a bit of Google product integration
and Chromium becomes Google Chrome.
V8 knows nothing about the DOM, the Document Object Model, as it is meant to just process the JavaScript. Blink
contains the layout engine that decides how to display a site. It makes sense that Node.js would only need V8 and not
Blink, because Node doesn’t need to know anything about the DOM.
Since V8 is written in C++ it compiles JavaScript directly to native, optimized, machine code before executing it,
instead of interpreting it in real time, which is what allows the Node.js to be so speedy and competitive in the server
marketplace.

Because of various engines - JS code can behave differently in browsers.

In 2009 Ryan Dahl, created a Node.js
Node is not a programming language, so it's wrong to say "I prefer C# TO Node", and it's not a framework, so we cannot
say "I prefer ASP.NET to Node", Node is a runtime environment for executing javascript code.
Runtime environment - it's a environment where code is running.

The main idea of single-thread non-blocking work - is thread can working with multiple requests, depending their
ready to be worked with or not.
e.g. Main thread get's a request to DB, it passes the request to DB, and work with next request, while first is
calculating. When DB calculates the data and return response - it's stored in event (callback) queue, thread when it
has no other work to do - picks a nearest to the queue exit callback (with DB data), and put's it in main thread.

Since Node is single threaded, it should not be used for application that needs to calculate some big CPU intensive
operations, because while processor calculates this operation for some request - other should wait for it. So the main
aim is data intensive and real-time applications.

One of the key concept in Node - is events.
e.g. We have a HTTP class, and saying we server listening some port, as soon as machine has new connection to that
port - HTTP class raises the event - "New Request", and we can catch it with handlers.

Express framework is build on top of Http module in node.

In server route /resources/id, we can have a multiple parameters /resources/id/subId they are for essential or
required values, and we have a query parameters /resources/id?sortBy=name - for optional things, that passing some
extra data to server.

With out express.json(), or body-parser - express doesn't see JSON objects that we are sending to it.

TIP: kill process on windows: netstat -ano | findstr :yourPortNumber && taskkill /PID typeyourPIDhere /F

Middleware.
The main idea of middleware, or middleware function that it takes a client request and return an response, or passes
it to the next middleware function. app.get('/', (req, res) => {}) - route handler - is a middleware function, or
app.use(express.json()) - express.json returns a middleware function, that takes a request and if request body is
a json string - it parses it to json object - and add a "body" property with this object to request, and returns it.
When request goes to the server - it's get invoked in request processing pipeline, in this pipeline we have one or more
middlewares, that either terminates pipeline by returning response, or passes request to another middleware.
We can use express.Router - to simplify paths.

MONGO
Install mongodb on mac:
$> brew install mongodb
$>sudo mkdir -p /data/db (We need to create storage for it)
$> sudo chown -R `id -un` /data/db (Set wright permissions to this folder)
$> mongod (Start daemon on mongodb, will start service on 27017)

Go to mongodb.com to download the client for it, called compass.

For Windows - download mongodb installer and client.
Add C:\Program Files\MongoDB\Server\4.2\bin to "path" system variables.
Create storage folder. oleh> md c:\data\db
run from terminal oleh> mongod

So Collection in mongo - same relation DB table
Documents in Collection - same as relation DB rows in table

In mongoose - a client to manage mongo - we have Schemas. In Scheme - we explain em... scheme of Document we want
to create in Collection. From Schema we can create a model, like a class which can create a document objects
in collection.
const humanScheme = new mongoose.Schema({name: String, age: Number}); - created schema for collection
const Human = mongoose.model('HumanCollection', humanScheme); - created model for collection
const human1 = new Human({name: "John", age: 18}) - created object to store in collection
await human1.save() - created document in 'HumanCollection'

Human.find() // filtering
	.limit(10) // limitation of result
	.sort({name: 1}) // sorted by name, -1 - means descending (по убыванию), 1 - ascending (по возрастанию)
	.select({name: 1, tags: 1}) // choose properties that we want to return from object.
	.find({name: /^super/ig}) // using RegExp
	.countDocuments() // to get number of found documents
	.skip(2) // means skip first two documents. Useful if pagination needed, works with limit e.g. .skip(2).limit(10)

So Schema is like class for
In Schema we can use types:
String
Number
Date
Buffer
Boolean
ObjectID - uniq identifier
Array

Comparing operators in mongoose
eq (equal)
ne (not equal)
gt (greater than)
gte (greater than or equal)
lt (less then)
lte (less then or equal)
in
nin (no in)
Genre.find({name: {$gt: 10}, someNumber: {$in: [10, 15, 20]}})

Logical operators
or
and
Genre.find().or([{name: 'This name'}, {isPublished: true}]).and([{name: 'This name'}, {isPublished: true}])

A few examples of queries
GenreModel.find({isPublished: true, tags: 'backend'}).sort({name: 1}).select('name author');
GenreModel.find({isPublished: true, tags: {$in: ['frontend', 'backend']}}).sort('-price').select('name author');
GenreModel.find({isPublished: true}).or([{name: /.*by.*/ig}, {price: {$gte: 15}}]).select('name author price');

Update document
Two ways to do that.
First - query first - means find the document, update it's fields, and save it. GenreModel.set({key: value}) - to update,
	or you can update properties of object directly.
Second - update directly in DB

Note about curl
curl --data '{"name":"Forth Course"}' --header "Content-Type: application/json" --request POST http://localhost:3000/api
curl -d "param1=value1&param2=value2" -H "Content-Type: application/x-www-form-urlencoded" -X POST http://localhost:3000/blahblah

