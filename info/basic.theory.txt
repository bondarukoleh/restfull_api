Node is about scale and speed of development.
To build highly-scalable (non blocking, async nature), data-intensive, and real-time apps.
Node uses Javascript - a lot of programmers know it.
Open-source libraries, you don't have to rebuild a lot of things.

Theory.
Every Browser has JS Engine, it takes JS Code and compiling a machine code from it, so computer can run it.
Edge has chakra (chromium for now), FireFox - SpiderMonkey (Gecko), Chrome V8 (Blink as rendering engine),
Safari - WebKit, Opera - Presto (chromium for now)

Wait what’s Blink? It’s a bit confusing, as Blink is Google Chrome’s rendering engine, V8 is the JavaScript Engine used
within Blink, and Chromium is the browser project that holds them all together. Add a bit of Google product integration
and Chromium becomes Google Chrome.
V8 knows nothing about the DOM, the Document Object Model, as it is meant to just process the JavaScript. Blink
contains the layout engine that decides how to display a site. It makes sense that Node.js would only need V8 and not
Blink, because Node doesn’t need to know anything about the DOM.
Since V8 is written in C++ it compiles JavaScript directly to native, optimized, machine code before executing it,
instead of interpreting it in real time, which is what allows the Node.js to be so speedy and competitive in the server
marketplace.

Because of various engines - JS code can behave differently in browsers.

In 2009 Ryan Dahl, created a Node.js
Node is not a programming language, so it's wrong to say "I prefer C# TO Node", and it's not a framework, so we cannot
say "I prefer ASP.NET to Node", Node is a runtime environment for executing javascript code.
Runtime environment - it's a environment where code is running.

The main idea of single-thread non-blocking work - is thread can working with multiple requests, depending their
ready to be worked with or not.
e.g. Main thread get's a request to DB, it passes the request to DB, and work with next request, while first is
calculating. When DB calculates the data and return response - it's stored in event (callback) queue, thread when it
has no other work to do - picks a nearest to the queue exit callback (with DB data), and put's it in main thread.

Since Node is single threaded, it should not be used for application that needs to calculate some big CPU intensive
operations, because while processor calculates this operation for some request - other should wait for it. So the main
aim is data intensive and real-time applications.

One of the key concept in Node - is events.
e.g. We have a HTTP class, and saying we server listening some port, as soon as machine has new connection to that
port - HTTP class raises the event - "New Request", and we can catch it with handlers.

Express framework is build on top of Http module in node.

In server route /resources/id, we can have a multiple parameters /resources/id/subId they are for essential or
required values, and we have a query parameters /resources/id?sortBy=name - for optional things, that passing some
extra data to server.

With out express.json(), or body-parser - express doesn't see JSON objects that we are sending to it.

TIP: kill process on windows: netstat -ano | findstr :yourPortNumber && taskkill /PID typeyourPIDhere /F

Middleware.
The main idea of middleware, or middleware function that it takes a client request and return an response, or passes
it to the next middleware function. app.get('/', (req, res) => {}) - route handler - is a middleware function, or
app.use(express.json()) - express.json returns a middleware function, that takes a request and if request body is
a json string - it parses it to json object - and add a "body" property with this object to request, and returns it.
